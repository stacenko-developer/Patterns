# Паттерны проектирования с примерами на C#
В данном репозитории содержатся реализации паттернов на языке программирования C#. Ниже вы можете ознакомиться с описанием паттернов, их назначением, а также преимуществами и недостатками. <br />
После изучения теории можете переходить в код - он хорошо задокументирован, поэтому разобраться в нем не составит труда. <br />
### В папке каждого паттерна содержатся: <br />
* его реализация в библиотеке классов; <br />
* демонстрация работы в консольном приложении; <br />
* [тестирование](https://github.com/stacenko-developer/UnitTests "тестирование") методов классов и проверка корректности реализации паттерна <br /><br />
__Также по мере изучения буду добавлять реализацию новых паттернов.__ <br /><br />

## Оглавление


1. [Порождающие (Creational)](#Порождающие (Creational))
    1. [Абстрактная фабрика (Abstract Factory)](#Абстрактная-фабрика)
    2. [Одиночка (Singleton)](#Одиночка-(Singleton))
2. [Структурные (Structural)](#Структурные-(Structural))
    1. [Адаптер (Adapter)](#Адаптер-(Adapter))
    2. [Декоратор (Decorator)](#Декоратор-(Decorator))
3. [Поведенческие (Behavioral)](#Поведенческие-(Behavioral))
    1. [Итератор (Iterator)](#Итератор-(Iterator))
    2. [Наблюдатель (Observer)](#Наблюдатель-(Observer))
    3. [Посредник (Mediator)](#Посредник-(Mediator))
4. [Архитектурные (Architectural)](#Архитектурные-(Architectural))
    1. [Внедрение зависимостей (Dependency Injection)](#Итератор-(Iterator))

## Порождающие (Creational)

С помощью пораждающих паттернов у нас есть возможность удобно и безопасносно создавать объекты или группы объектов.
____
### Абстрактная фабрика
__Абстрактная фабрика__ – это порождающий паттерн проектирования, который позволяет создавать семейства связанных объектов, не привязываясь к конкретным классам создаваемых объектов. <br />
Нам нужен такой способ создавать объекты, чтобы они сочетались с другими одного и того же семейства. Кроме того, мы не хотим вносить изменения в существующий код при добавлении новых объектов в программу. <br /><br>
> Данный паттерн необходимо использовать, когда система не должна зависеть от способа создания и компоновки новых объектов и когда создаваемые объекты должны использоваться вместе и являются взаимосвязанными.

<br>Предположим, что у нас есть какая-то компания, в которой работают сотрудники. Для простоты у нас есть два типа работников: __программист__ и __директор__. У каждого сотрудника есть девайс (компьютер и ноутбук) и служебный транспорт (пусть будет BMW и LADA). <br>
Теперь нам необходимо реализовать __интерфейс__ фабрики по созданию сотрудника, в котором будет 2 метода: создание объекта __рабочего устройства__ и создание объекта __рабочего автомобиля__. 
```C#
/// <summary>
/// Фабрика сотрудника.
/// </summary>
public interface IWorkerFactory 
{
	/// <summary>
	/// Создание рабочего устройства для сотрудника. 
	/// </summary>
	/// <returns>Рабочее устройство.</returns>
	WorkingDevice CreateWorkingDevice();

	/// <summary>
	/// Создание рабочего автомобиля.
	/// </summary>
	/// <returns>Рабочий автомобиль.</returns>
	WorkingCar CreateWorkingCar();
}
```
Далее нам необходимо создать фабрику по созданию программиста и директора, реализующую интерфейс __IWorkerFactory__. Рассмотрим пример фабрики по созданию директора. У нас метод CreateWorkingCar возвращает объект автомобиля марки __BMW__ и объект __компьютера__ в качестве рабочего устройства.
```C#
	/// <summary>
	/// Фабрика директора.
	/// </summary>
	public class DirectorFactory : IWorkerFactory 
	{
		#region Методы.
		/// <summary>
		/// Создание рабочего автомобиля.
		/// </summary>
		/// <returns>Рабочий автомобиль.</returns>
		public WorkingCar CreateWorkingCar() => new BMW();

		/// <summary>
		/// Создание рабочего устройства.
		/// </summary>
		/// <returns>Рабочее устройство.</returns>
		public WorkingDevice CreateWorkingDevice() => new Computer();
		#endregion
	}
```
